import numpy as np
from _typeshed import Incomplete
from pydantic import BaseModel
from qcelemental.models.basemodels import ProtoModel as ProtoModel
from typing import Callable, Dict, List, Tuple, Union

pp: Incomplete

def tnm() -> str: ...
def compare_values(expected: Union[float, List, np.ndarray], computed: Union[float, List, np.ndarray], label: str = None, *, atol: float = 1e-06, rtol: float = 1e-16, equal_nan: bool = False, equal_phase: bool = False, passnone: bool = False, quiet: bool = False, return_message: bool = False, return_handler: Callable = None) -> Union[bool, Tuple[bool, str]]: ...
def compare(expected: Union[int, bool, str, List[int], np.ndarray], computed: Union[int, bool, str, List[int], np.ndarray], label: str = None, *, equal_phase: bool = False, quiet: bool = False, return_message: bool = False, return_handler: Callable = None) -> Union[bool, Tuple[bool, str]]: ...
def compare_recursive(expected: Union[Dict, BaseModel, 'ProtoModel'], computed: Union[Dict, BaseModel, 'ProtoModel'], label: str = None, *, atol: float = 1e-06, rtol: float = 1e-16, forgive: List[str] = None, equal_phase: Union[bool, List] = False, quiet: bool = False, return_message: bool = False, return_handler: Callable = None) -> Union[bool, Tuple[bool, str]]: ...
def compare_molrecs(expected, computed, label: str = None, *, atol: float = 1e-06, rtol: float = 1e-16, forgive: Incomplete | None = None, verbose: int = 1, relative_geoms: str = 'exact', return_message: bool = False, return_handler: Callable = None) -> bool: ...
