from .auth import GroupInfo as GroupInfo, RoleInfo as RoleInfo, UserInfo as UserInfo, is_valid_groupname as is_valid_groupname, is_valid_password as is_valid_password, is_valid_rolename as is_valid_rolename, is_valid_username as is_valid_username
from .base_models import CommonBulkGetBody as CommonBulkGetBody, CommonBulkGetNamesBody as CommonBulkGetNamesBody
from .client_base import PortalClientBase as PortalClientBase
from .dataset_models import BaseDataset as BaseDataset, DatasetAddBody as DatasetAddBody, DatasetDeleteParams as DatasetDeleteParams, DatasetQueryModel as DatasetQueryModel, DatasetQueryRecords as DatasetQueryRecords, dataset_from_dict as dataset_from_dict
from .internal_jobs import InternalJob as InternalJob, InternalJobQueryFilters as InternalJobQueryFilters, InternalJobQueryIterator as InternalJobQueryIterator, InternalJobStatusEnum as InternalJobStatusEnum
from .managers import ComputeManager as ComputeManager, ManagerQueryFilters as ManagerQueryFilters, ManagerQueryIterator as ManagerQueryIterator
from .metadata_models import DeleteMetadata as DeleteMetadata, InsertMetadata as InsertMetadata, UpdateMetadata as UpdateMetadata
from .molecules import Molecule as Molecule, MoleculeIdentifiers as MoleculeIdentifiers, MoleculeModifyBody as MoleculeModifyBody, MoleculeQueryFilters as MoleculeQueryFilters, MoleculeQueryIterator as MoleculeQueryIterator
from .record_models import BaseRecord as BaseRecord, PriorityEnum as PriorityEnum, RecordDeleteBody as RecordDeleteBody, RecordModifyBody as RecordModifyBody, RecordQueryFilters as RecordQueryFilters, RecordQueryIterator as RecordQueryIterator, RecordRevertBody as RecordRevertBody, RecordStatusEnum as RecordStatusEnum, records_from_dicts as records_from_dicts
from .serverinfo import AccessLogQueryFilters as AccessLogQueryFilters, AccessLogQueryIterator as AccessLogQueryIterator, AccessLogSummary as AccessLogSummary, AccessLogSummaryEntry as AccessLogSummaryEntry, AccessLogSummaryFilters as AccessLogSummaryFilters, DeleteBeforeDateBody as DeleteBeforeDateBody, ErrorLogQueryFilters as ErrorLogQueryFilters, ErrorLogQueryIterator as ErrorLogQueryIterator, ServerStatsQueryFilters as ServerStatsQueryFilters, ServerStatsQueryIterator as ServerStatsQueryIterator
from .utils import chunk_iterable as chunk_iterable, make_list as make_list
from datetime import datetime
from qcportal.gridoptimization import GridoptimizationAddBody as GridoptimizationAddBody, GridoptimizationKeywords as GridoptimizationKeywords, GridoptimizationQueryFilters as GridoptimizationQueryFilters, GridoptimizationRecord as GridoptimizationRecord
from qcportal.manybody import ManybodyAddBody as ManybodyAddBody, ManybodyKeywords as ManybodyKeywords, ManybodyQueryFilters as ManybodyQueryFilters, ManybodyRecord as ManybodyRecord
from qcportal.neb import NEBAddBody as NEBAddBody, NEBKeywords as NEBKeywords, NEBQueryFilters as NEBQueryFilters, NEBRecord as NEBRecord
from qcportal.optimization import OptimizationAddBody as OptimizationAddBody, OptimizationProtocols as OptimizationProtocols, OptimizationQueryFilters as OptimizationQueryFilters, OptimizationRecord as OptimizationRecord, OptimizationSpecification as OptimizationSpecification
from qcportal.reaction import ReactionAddBody as ReactionAddBody, ReactionKeywords as ReactionKeywords, ReactionQueryFilters as ReactionQueryFilters, ReactionRecord as ReactionRecord
from qcportal.services.models import ServiceSubtaskRecord as ServiceSubtaskRecord
from qcportal.singlepoint import QCSpecification as QCSpecification, SinglepointAddBody as SinglepointAddBody, SinglepointDriver as SinglepointDriver, SinglepointProtocols as SinglepointProtocols, SinglepointQueryFilters as SinglepointQueryFilters, SinglepointRecord as SinglepointRecord
from qcportal.torsiondrive import TorsiondriveAddBody as TorsiondriveAddBody, TorsiondriveKeywords as TorsiondriveKeywords, TorsiondriveQueryFilters as TorsiondriveQueryFilters, TorsiondriveRecord as TorsiondriveRecord
from typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple, Union

class PortalClient(PortalClientBase):
    def __init__(self, address: str, username: Optional[str] = None, password: Optional[str] = None, verify: bool = True, show_motd: bool = True) -> None: ...
    def get_server_information(self) -> Dict[str, Any]: ...
    def get_motd(self) -> str: ...
    def set_motd(self, new_motd: str) -> str: ...
    def list_datasets(self): ...
    def list_datasets_table(self) -> str: ...
    def print_datasets_table(self) -> None: ...
    def get_dataset(self, dataset_type: str, dataset_name: str): ...
    def query_dataset_records(self, record_id: Union[int, Iterable[int]], dataset_type: Optional[Iterable[str]] = None): ...
    def get_dataset_by_id(self, dataset_id: int): ...
    def get_dataset_status_by_id(self, dataset_id: int) -> Dict[str, Dict[RecordStatusEnum, int]]: ...
    def add_dataset(self, dataset_type: str, name: str, description: Optional[str] = None, tagline: Optional[str] = None, tags: Optional[List[str]] = None, group: Optional[str] = None, provenance: Optional[Dict[str, Any]] = None, visibility: bool = True, default_tag: str = '*', default_priority: PriorityEnum = ..., metadata: Optional[Dict[str, Any]] = None, owner_group: Optional[str] = None, existing_ok: bool = False) -> BaseDataset: ...
    def delete_dataset(self, dataset_id: int, delete_records: bool): ...
    def get_molecules(self, molecule_ids: Union[int, Sequence[int]], missing_ok: bool = False) -> Union[Optional[Molecule], List[Optional[Molecule]]]: ...
    def query_molecules(self, *, molecule_hash: Optional[Union[str, Iterable[str]]] = None, molecular_formula: Optional[Union[str, Iterable[str]]] = None, identifiers: Optional[Dict[str, Union[str, Iterable[str]]]] = None, limit: Optional[int] = None) -> MoleculeQueryIterator: ...
    def add_molecules(self, molecules: Sequence[Molecule]) -> Tuple[InsertMetadata, List[int]]: ...
    def modify_molecule(self, molecule_id: int, name: Optional[str] = None, comment: Optional[str] = None, identifiers: Optional[Union[Dict[str, Any], MoleculeIdentifiers]] = None, overwrite_identifiers: bool = False) -> UpdateMetadata: ...
    def delete_molecules(self, molecule_ids: Union[int, Sequence[int]]) -> DeleteMetadata: ...
    def get_records(self, record_ids: Union[int, Sequence[int]], missing_ok: bool = False, *, include: Optional[Iterable[str]] = None) -> Union[List[Optional[BaseRecord]], Optional[BaseRecord]]: ...
    def query_records(self, *, record_id: Optional[Union[int, Iterable[int]]] = None, record_type: Optional[Union[str, Iterable[str]]] = None, manager_name: Optional[Union[str, Iterable[str]]] = None, status: Optional[Union[RecordStatusEnum, Iterable[RecordStatusEnum]]] = None, dataset_id: Optional[Union[int, Iterable[int]]] = None, parent_id: Optional[Union[int, Iterable[int]]] = None, child_id: Optional[Union[int, Iterable[int]]] = None, created_before: Optional[Union[datetime, str]] = None, created_after: Optional[Union[datetime, str]] = None, modified_before: Optional[Union[datetime, str]] = None, modified_after: Optional[Union[datetime, str]] = None, owner_user: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, owner_group: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, limit: int = None, include: Optional[Iterable[str]] = None) -> RecordQueryIterator[BaseRecord]: ...
    def reset_records(self, record_ids: Union[int, Sequence[int]]) -> UpdateMetadata: ...
    def cancel_records(self, record_ids: Union[int, Sequence[int]]) -> UpdateMetadata: ...
    def invalidate_records(self, record_ids: Union[int, Sequence[int]]) -> UpdateMetadata: ...
    def delete_records(self, record_ids: Union[int, Sequence[int]], soft_delete: bool = True, delete_children: bool = True) -> DeleteMetadata: ...
    def uninvalidate_records(self, record_ids: Union[int, Sequence[int]]) -> UpdateMetadata: ...
    def uncancel_records(self, record_ids: Union[int, Sequence[int]]) -> UpdateMetadata: ...
    def undelete_records(self, record_ids: Union[int, Sequence[int]]) -> UpdateMetadata: ...
    def modify_records(self, record_ids: Union[int, Sequence[int]], new_tag: Optional[str] = None, new_priority: Optional[PriorityEnum] = None) -> UpdateMetadata: ...
    def add_comment(self, record_ids: Union[int, Sequence[int]], comment: str) -> UpdateMetadata: ...
    def get_waiting_reason(self, record_id: int) -> Dict[str, Any]: ...
    def add_singlepoints(self, molecules: Union[int, Molecule, List[Union[int, Molecule]]], program: str, driver: str, method: str, basis: Optional[str], keywords: Optional[Dict[str, Any]] = None, protocols: Optional[Union[SinglepointProtocols, Dict[str, Any]]] = None, tag: str = '*', priority: PriorityEnum = ..., owner_group: Optional[str] = None, find_existing: bool = True) -> Tuple[InsertMetadata, List[int]]: ...
    def get_singlepoints(self, record_ids: Union[int, Sequence[int]], missing_ok: bool = False, *, include: Optional[Iterable[str]] = None) -> Union[Optional[SinglepointRecord], List[Optional[SinglepointRecord]]]: ...
    def query_singlepoints(self, *, record_id: Optional[Union[int, Iterable[int]]] = None, manager_name: Optional[Union[str, Iterable[str]]] = None, status: Optional[Union[RecordStatusEnum, Iterable[RecordStatusEnum]]] = None, dataset_id: Optional[Union[int, Iterable[int]]] = None, parent_id: Optional[Union[int, Iterable[int]]] = None, created_before: Optional[Union[datetime, str]] = None, created_after: Optional[Union[datetime, str]] = None, modified_before: Optional[Union[datetime, str]] = None, modified_after: Optional[Union[datetime, str]] = None, program: Optional[Union[str, Iterable[str]]] = None, driver: Optional[Union[SinglepointDriver, Iterable[SinglepointDriver]]] = None, method: Optional[Union[str, Iterable[str]]] = None, basis: Optional[Union[str, Iterable[Optional[str]]]] = None, keywords: Optional[Union[Dict[str, Any], Iterable[Dict[str, Any]]]] = None, molecule_id: Optional[Union[int, Iterable[int]]] = None, owner_user: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, owner_group: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, limit: Optional[int] = None, include: Optional[Iterable[str]] = None) -> RecordQueryIterator[SinglepointRecord]: ...
    def add_optimizations(self, initial_molecules: Union[int, Molecule, List[Union[int, Molecule]]], program: str, qc_specification: QCSpecification, keywords: Optional[Dict[str, Any]] = None, protocols: Optional[OptimizationProtocols] = None, tag: str = '*', priority: PriorityEnum = ..., owner_group: Optional[str] = None, find_existing: bool = True) -> Tuple[InsertMetadata, List[int]]: ...
    def get_optimizations(self, record_ids: Union[int, Sequence[int]], missing_ok: bool = False, *, include: Optional[Iterable[str]] = None) -> Union[Optional[OptimizationRecord], List[Optional[OptimizationRecord]]]: ...
    def query_optimizations(self, *, record_id: Optional[Union[int, Iterable[int]]] = None, manager_name: Optional[Union[str, Iterable[str]]] = None, status: Optional[Union[RecordStatusEnum, Iterable[RecordStatusEnum]]] = None, dataset_id: Optional[Union[int, Iterable[int]]] = None, parent_id: Optional[Union[int, Iterable[int]]] = None, child_id: Optional[Union[int, Iterable[int]]] = None, created_before: Optional[Union[datetime, str]] = None, created_after: Optional[Union[datetime, str]] = None, modified_before: Optional[Union[datetime, str]] = None, modified_after: Optional[Union[datetime, str]] = None, program: Optional[Union[str, Iterable[str]]] = None, qc_program: Optional[Union[str, Iterable[str]]] = None, qc_method: Optional[Union[str, Iterable[str]]] = None, qc_basis: Optional[Union[str, Iterable[Optional[str]]]] = None, initial_molecule_id: Optional[Union[int, Iterable[int]]] = None, final_molecule_id: Optional[Union[int, Iterable[int]]] = None, owner_user: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, owner_group: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, limit: Optional[int] = None, include: Optional[Iterable[str]] = None) -> RecordQueryIterator[OptimizationRecord]: ...
    def add_torsiondrives(self, initial_molecules: List[List[Union[int, Molecule]]], program: str, optimization_specification: OptimizationSpecification, keywords: Union[TorsiondriveKeywords, Dict[str, Any]], tag: str = '*', priority: PriorityEnum = ..., owner_group: Optional[str] = None, find_existing: bool = True) -> Tuple[InsertMetadata, List[int]]: ...
    def get_torsiondrives(self, record_ids: Union[int, Sequence[int]], missing_ok: bool = False, *, include: Optional[Iterable[str]] = None) -> Union[Optional[TorsiondriveRecord], List[Optional[TorsiondriveRecord]]]: ...
    def query_torsiondrives(self, *, record_id: Optional[Union[int, Iterable[int]]] = None, manager_name: Optional[Union[str, Iterable[str]]] = None, status: Optional[Union[RecordStatusEnum, Iterable[RecordStatusEnum]]] = None, dataset_id: Optional[Union[int, Iterable[int]]] = None, parent_id: Optional[Union[int, Iterable[int]]] = None, child_id: Optional[Union[int, Iterable[int]]] = None, created_before: Optional[Union[datetime, str]] = None, created_after: Optional[Union[datetime, str]] = None, modified_before: Optional[Union[datetime, str]] = None, modified_after: Optional[Union[datetime, str]] = None, program: Optional[Union[str, Iterable[str]]] = None, optimization_program: Optional[Union[str, Iterable[str]]] = None, qc_program: Optional[Union[str, Iterable[str]]] = None, qc_method: Optional[Union[str, Iterable[str]]] = None, qc_basis: Optional[Union[str, Iterable[str]]] = None, initial_molecule_id: Optional[Union[int, Iterable[int]]] = None, owner_user: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, owner_group: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, limit: Optional[int] = None, include: Optional[Iterable[str]] = None) -> RecordQueryIterator[TorsiondriveRecord]: ...
    def add_gridoptimizations(self, initial_molecules: Union[int, Molecule, Sequence[Union[int, Molecule]]], program: str, optimization_specification: OptimizationSpecification, keywords: Union[GridoptimizationKeywords, Dict[str, Any]], tag: str = '*', priority: PriorityEnum = ..., owner_group: Optional[str] = None, find_existing: bool = True) -> Tuple[InsertMetadata, List[int]]: ...
    def get_gridoptimizations(self, record_ids: Union[int, Sequence[int]], missing_ok: bool = False, *, include: Optional[Iterable[str]] = None) -> Union[Optional[GridoptimizationRecord], List[Optional[GridoptimizationRecord]]]: ...
    def query_gridoptimizations(self, *, record_id: Optional[Union[int, Iterable[int]]] = None, manager_name: Optional[Union[str, Iterable[str]]] = None, status: Optional[Union[RecordStatusEnum, Iterable[RecordStatusEnum]]] = None, dataset_id: Optional[Union[int, Iterable[int]]] = None, parent_id: Optional[Union[int, Iterable[int]]] = None, child_id: Optional[Union[int, Iterable[int]]] = None, created_before: Optional[Union[datetime, str]] = None, created_after: Optional[Union[datetime, str]] = None, modified_before: Optional[Union[datetime, str]] = None, modified_after: Optional[Union[datetime, str]] = None, program: Optional[Union[str, Iterable[str]]] = None, optimization_program: Optional[Union[str, Iterable[str]]] = None, qc_program: Optional[Union[str, Iterable[str]]] = None, qc_method: Optional[Union[str, Iterable[str]]] = None, qc_basis: Optional[Union[str, Iterable[Optional[str]]]] = None, initial_molecule_id: Optional[Union[int, Iterable[int]]] = None, owner_user: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, owner_group: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, limit: Optional[int] = None, include: Optional[Iterable[str]] = None) -> RecordQueryIterator[GridoptimizationRecord]: ...
    def add_reactions(self, stoichiometries: Sequence[Sequence[Sequence[float, Union[int, Molecule]]]], program: str, singlepoint_specification: Optional[QCSpecification], optimization_specification: Optional[OptimizationSpecification], keywords: ReactionKeywords, tag: str = '*', priority: PriorityEnum = ..., owner_group: Optional[str] = None, find_existing: bool = True) -> Tuple[InsertMetadata, List[int]]: ...
    def get_reactions(self, record_ids: Union[int, Sequence[int]], missing_ok: bool = False, *, include: Optional[Iterable[str]] = None) -> Union[Optional[ReactionRecord], List[Optional[ReactionRecord]]]: ...
    def query_reactions(self, *, record_id: Optional[Union[int, Iterable[int]]] = None, manager_name: Optional[Union[str, Iterable[str]]] = None, status: Optional[Union[RecordStatusEnum, Iterable[RecordStatusEnum]]] = None, dataset_id: Optional[Union[int, Iterable[int]]] = None, parent_id: Optional[Union[int, Iterable[int]]] = None, child_id: Optional[Union[int, Iterable[int]]] = None, created_before: Optional[Union[datetime, str]] = None, created_after: Optional[Union[datetime, str]] = None, modified_before: Optional[Union[datetime, str]] = None, modified_after: Optional[Union[datetime, str]] = None, program: Optional[Union[str, Iterable[str]]] = None, optimization_program: Optional[Iterable[Optional[str]]] = None, qc_program: Optional[Union[str, Iterable[str]]] = None, qc_method: Optional[Union[str, Iterable[str]]] = None, qc_basis: Optional[Union[str, Iterable[str]]] = None, molecule_id: Optional[Union[int, Iterable[int]]] = None, owner_user: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, owner_group: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, limit: Optional[int] = None, include: Optional[Iterable[str]] = None) -> RecordQueryIterator[ReactionRecord]: ...
    def add_manybodys(self, initial_molecules: Sequence[Union[int, Molecule]], program: str, singlepoint_specification: QCSpecification, keywords: ManybodyKeywords, tag: str = '*', priority: PriorityEnum = ..., owner_group: Optional[str] = None, find_existing: bool = True) -> Tuple[InsertMetadata, List[int]]: ...
    def get_manybodys(self, record_ids: Union[int, Sequence[int]], missing_ok: bool = False, *, include: Optional[Iterable[str]] = None) -> Union[Optional[ManybodyRecord], List[Optional[ManybodyRecord]]]: ...
    def query_manybodys(self, *, record_id: Optional[Union[int, Iterable[int]]] = None, manager_name: Optional[Union[str, Iterable[str]]] = None, status: Optional[Union[RecordStatusEnum, Iterable[RecordStatusEnum]]] = None, dataset_id: Optional[Union[int, Iterable[int]]] = None, parent_id: Optional[Union[int, Iterable[int]]] = None, child_id: Optional[Union[int, Iterable[int]]] = None, created_before: Optional[Union[datetime, str]] = None, created_after: Optional[Union[datetime, str]] = None, modified_before: Optional[Union[datetime, str]] = None, modified_after: Optional[Union[datetime, str]] = None, program: Optional[Union[str, Iterable[str]]] = None, qc_program: Optional[Union[str, Iterable[str]]] = None, qc_method: Optional[Union[str, Iterable[str]]] = None, qc_basis: Optional[Union[str, Iterable[str]]] = None, initial_molecule_id: Optional[Union[int, Iterable[int]]] = None, owner_user: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, owner_group: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, limit: Optional[int] = None, include: Optional[Iterable[str]] = None) -> RecordQueryIterator[ManybodyRecord]: ...
    def add_nebs(self, initial_chains: List[List[Union[int, Molecule]]], program: str, singlepoint_specification: QCSpecification, optimization_specification: Optional[OptimizationSpecification], keywords: Union[NEBKeywords, Dict[str, Any]], tag: str = '*', priority: PriorityEnum = ..., owner_group: Optional[str] = None, find_existing: bool = True) -> Tuple[InsertMetadata, List[int]]: ...
    def get_nebs(self, record_ids: Union[int, Sequence[int]], missing_ok: bool = False, *, include: Optional[Iterable[str]] = None) -> Union[Optional[NEBRecord], List[Optional[NEBRecord]]]: ...
    def query_nebs(self, *, record_id: Optional[Union[int, Iterable[int]]] = None, manager_name: Optional[Union[str, Iterable[str]]] = None, status: Optional[Union[RecordStatusEnum, Iterable[RecordStatusEnum]]] = None, dataset_id: Optional[Union[int, Iterable[int]]] = None, parent_id: Optional[Union[int, Iterable[int]]] = None, child_id: Optional[Union[int, Iterable[int]]] = None, created_before: Optional[Union[datetime, str]] = None, created_after: Optional[Union[datetime, str]] = None, modified_before: Optional[Union[datetime, str]] = None, modified_after: Optional[Union[datetime, str]] = None, program: Optional[Union[str, Iterable[str]]] = None, qc_program: Optional[Union[str, Iterable[str]]] = None, qc_method: Optional[Union[str, Iterable[str]]] = None, qc_basis: Optional[Union[str, Iterable[str]]] = None, molecule_id: Optional[Union[int, Iterable[int]]] = None, owner_user: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, owner_group: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, limit: Optional[int] = None, include: Optional[Iterable[str]] = None) -> RecordQueryIterator[NEBRecord]: ...
    def get_managers(self, names: Union[str, Sequence[str]], missing_ok: bool = False) -> Union[Optional[ComputeManager], List[Optional[ComputeManager]]]: ...
    def query_managers(self, *, manager_id: Optional[Union[int, Iterable[int]]] = None, name: Optional[Union[str, Iterable[str]]] = None, cluster: Optional[Union[str, Iterable[str]]] = None, hostname: Optional[Union[str, Iterable[str]]] = None, status: Optional[Union[RecordStatusEnum, Iterable[RecordStatusEnum]]] = None, modified_before: Optional[Union[datetime, str]] = None, modified_after: Optional[Union[datetime, str]] = None, limit: Optional[int] = None) -> ManagerQueryIterator: ...
    def query_server_stats(self, *, before: Optional[Union[datetime, str]] = None, after: Optional[Union[datetime, str]] = None, limit: Optional[int] = None) -> ServerStatsQueryIterator: ...
    def delete_server_stats(self, before: datetime) -> int: ...
    def query_access_log(self, *, module: Optional[Union[str, Iterable[str]]] = None, method: Optional[Union[str, Iterable[str]]] = None, before: Optional[Union[datetime, str]] = None, after: Optional[Union[datetime, str]] = None, user: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, limit: Optional[int] = None) -> AccessLogQueryIterator: ...
    def delete_access_log(self, before: datetime) -> int: ...
    def query_error_log(self, *, error_id: Optional[Union[int, Iterable[int]]] = None, user: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, before: Optional[Union[datetime, str]] = None, after: Optional[Union[datetime, str]] = None, limit: Optional[int] = None) -> ErrorLogQueryIterator: ...
    def delete_error_log(self, before: datetime) -> int: ...
    def get_internal_job(self, job_id: int) -> InternalJob: ...
    def query_internal_jobs(self, *, job_id: Optional[int, Iterable[int]] = None, name: Optional[Union[str, Iterable[str]]] = None, user: Optional[Union[int, str, Iterable[Union[int, str]]]] = None, runner_hostname: Optional[Union[str, Iterable[str]]] = None, status: Optional[Union[InternalJobStatusEnum, Iterable[InternalJobStatusEnum]]] = None, last_updated_before: Optional[Union[datetime, str]] = None, last_updated_after: Optional[Union[datetime, str]] = None, added_before: Optional[Union[datetime, str]] = None, added_after: Optional[Union[datetime, str]] = None, scheduled_before: Optional[Union[datetime, str]] = None, scheduled_after: Optional[Union[datetime, str]] = None, limit: Optional[int] = None) -> InternalJobQueryIterator: ...
    def cancel_internal_job(self, job_id: int): ...
    def delete_internal_job(self, job_id: int): ...
    def query_access_summary(self, *, group_by: str = 'day', before: Optional[Union[datetime, str]] = None, after: Optional[Union[datetime, str]] = None) -> AccessLogSummary: ...
    def list_roles(self) -> List[RoleInfo]: ...
    def get_role(self, rolename: str) -> RoleInfo: ...
    def add_role(self, role_info: RoleInfo) -> None: ...
    def modify_role(self, role_info: RoleInfo) -> RoleInfo: ...
    def delete_role(self, rolename: str) -> None: ...
    def list_groups(self) -> List[GroupInfo]: ...
    def get_group(self, groupname_or_id: Union[int, str]) -> GroupInfo: ...
    def add_group(self, group_info: GroupInfo) -> None: ...
    def delete_group(self, groupname_or_id: Union[int, str]): ...
    def list_users(self) -> List[UserInfo]: ...
    def get_user(self, username_or_id: Optional[Union[int, str]] = None) -> UserInfo: ...
    def add_user(self, user_info: UserInfo, password: Optional[str] = None) -> str: ...
    def modify_user(self, user_info: UserInfo) -> UserInfo: ...
    def change_user_password(self, username_or_id: Optional[Union[int, str]] = None, new_password: Optional[str] = None) -> str: ...
    def delete_user(self, username_or_id: Union[int, str]) -> None: ...
